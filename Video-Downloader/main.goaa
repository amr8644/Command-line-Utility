package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"math"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"golang.org/x/sync/errgroup"
)

var percent int
var verbose bool
var audio bool
var outputDirectory string

type writeCounter struct {
	BytesDownloaded int64
	TotalBytes      int64
}

func getMetaData(id string) (string, string, error) {
	log.Printf("getMetaData for ID: %v", id)

	metaURL := "https://www.youtube.com/get_video_info?video_id=" + id

	info(fmt.Sprintf("Making a HTTP GET request thru %s...", metaURL))

	resp, err := http.Get(metaURL)
	var fileName string
	var downloadURL string

	if err != nil {
		return fileName, downloadURL, fmt.Errorf("GoTube: Failed to acquire video info: %v", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return fileName, downloadURL, fmt.Errorf("GoTube: Bad status: %s (%s)", resp.Status, http.StatusText(resp.StatusCode))
	}

	byteArray, _ := ioutil.ReadAll(resp.Body)
	log.Printf("received: %v", string(byteArray))

	data := make(map[string]interface{})
	err = parseStr(string(byteArray[:]), data)
	if err != nil {
		return fileName, downloadURL, fmt.Errorf("GoTube: Failed to parse video info response: %v", err)
	}

	// We only need to retrieve video title, format and download url nothing else

	log.Printf("player_response: %v", data["player_response"])
	var videoData map[string]interface{}
	err = json.Unmarshal([]byte(data["player_response"].(string)), &videoData)
	if err != nil {
		return fileName, downloadURL, fmt.Errorf("GoTube: Failed to unmarshal video info data: %v", err)
	}

	log.Printf("videoData: %v", videoData)
	for key, value := range videoData {
		log.Printf("videoData: %v - %v", key, value)
	}
	log.Printf("videoDetails: %v", videoData["videoDetails"])
	log.Printf("streamingData: %v", videoData["streamingData"])

	if videoData["streamingData"] == nil {
		return fileName, downloadURL, fmt.Errorf("GoTube: streamingData is missing from this video '%v'", id)
	}

	videoDetails := videoData["videoDetails"].(map[string]interface{})
	streamingData := videoData["streamingData"].(map[string]interface{})
	formats := streamingData["formats"].([]interface{})

	// Let's try the first format...
	moreData := formats[0].(map[string]interface{})
	moreData["mime"] = moreData["mimeType"]
	s := moreData["mime"].(string)

	title := strings.Replace(strings.ToLower(videoDetails["title"].(string)), " ", "_", -1)
	format := s[strings.Index(s, "/")+1 : strings.Index(s, ";")]
	downloadURL = moreData["url"].(string)

	// Remove characters like ':' and '?' in the video title
	re := regexp.MustCompile(`[^A-Za-z0-9.\_\-]`)
	fileName = re.ReplaceAllString(title+"."+format, "")

	return fileName, downloadURL, nil
}

func checkParameters(videoURL string) (string, error) {
	var id string
	var err error

	isMatch, err := regexp.MatchString(`https://www\.youtube\.com/watch\?v=[\w-]+`, videoURL) // TODO need better regex pattern
	if err != nil {
		return id, err
	}

	if !isMatch {
		return id, fmt.Errorf("GoTube: Invalid YouTube URL")
	}

	// Check if the given file/directory exists
	var fileInfo os.FileInfo
	fileInfo, err = os.Stat(outputDirectory)
	if err != nil {
		if os.IsNotExist(err) {
			return id, fmt.Errorf("GoTube: The output directory '%v' doesn't exist", outputDirectory)
		}
		return id, err
	}
	if !fileInfo.Mode().IsDir() {
		return id, fmt.Errorf("GoTube: The directory '%v' is a file", outputDirectory)
	}

	var reprURL *url.URL
	reprURL, err = url.Parse(videoURL)
	if err != nil {
		return id, err
	}
	id = reprURL.Query()["v"][0]

	return id, nil
}

func downloadYTVideo(videoURL string) error {
	id, err := checkParameters(videoURL)
	if err != nil {
		return err
	}

	fileName, downloadURL, err := getMetaData(id)
	if err != nil {
		return err
	}
	path := filepath.Join(outputDirectory, fileName)

	info(fmt.Sprintf("Creating a file %s...", path))

	output, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("GoTube: Failed to create video file: %v", err)
	}
	defer output.Close()

	client := &http.Client{}

	// Determine the video size in bytes
	resp, err := client.Head(downloadURL)
	if err != nil {
		return fmt.Errorf("GoTube: Failed to issue HEAD request for download URL: %v", err)
	}

	videoSize, _ := strconv.ParseInt(resp.Header.Get("Content-Length"), 10, 64)

	request, _ := http.NewRequest("GET", downloadURL, nil)
	request.Header.Set("Cache-Control", "public")
	request.Header.Set("Content-Description", "File Transfer")
	request.Header.Set("Content-Disposition", "attachment; filename="+fileName)
	request.Header.Set("Content-Type", "application/zip")
	request.Header.Set("Content-Transfer-Encoding", "binary")

	info(fmt.Sprintf("Making another HTTP GET Request thru %s...", downloadURL))

	resp, err = client.Do(request)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("GoTube: Bad status: %s (%s)", resp.Status, http.StatusText(resp.StatusCode))
	}

	var body io.Reader

	if !verbose {
		body = resp.Body
	} else {
		go displayStatus()
		body = io.TeeReader(resp.Body, &writeCounter{0, videoSize}) // Pipe stream
	}

	_, err = io.Copy(output, body)

	if err != nil {
		return fmt.Errorf("GoTube: Unable to download the video! :(")
	}
	info(fmt.Sprint("The video downloaded successfully! :))"))

	if audio {
		err := saveAudio(outputDirectory, fileName, path)
		return err
	}

	return nil
}

func saveAudio(outputDirectory, fileName, path string) error {
	audioFile := filepath.Join(outputDirectory, strings.TrimRight(fileName, filepath.Ext(fileName))+".mp3")

	info(fmt.Sprintf("Creating a file %s...", audioFile))

	ffmpeg, err := exec.LookPath("ffmpeg")
	if err != nil {
		return fmt.Errorf("ffmpeg not found")
	}

	cmd := exec.Command(ffmpeg, "-i", path, "-vn", "-ar", "44100", "-ac", "1", "-b:a", "128k", "-f", "mp3", audioFile)

	if verbose {
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
	}

	err = cmd.Run()

	if err != nil {
		return err
	}

	info(fmt.Sprint("The video audio extracted successfully! :))"))
	return nil
}

func download(URLs []string) error {
	eg, ctx := errgroup.WithContext(context.Background())
	for _, currentURL := range URLs {
		log.Printf("URL: %s", currentURL)
		currentURL := currentURL
		eg.Go(func() error {
			select {
			case <-ctx.Done():
				fmt.Println("Canceled:", currentURL)
				return nil
			default:
				err := downloadYTVideo(currentURL)
				fmt.Println(err)
				return err
			}
		})
	}

	return eg.Wait()
}

func main() {
	flag.Usage = func() {
		fmt.Println("Usage: gotube [-outdir=<OUT_DIRECTORY>] [-v] [-d] [-a] <YT_VID_URL>\n")
	}

	// if there is no argument then shows the usage
	if len(os.Args) == 1 {
		flag.Usage()
	}

	var debug bool

	flag.StringVar(&outputDirectory, "outdir", ".", "Directory where you want the video to be downloaded")
	flag.BoolVar(&verbose, "v", false, "If true, GoTube will display detailed download process")
	flag.BoolVar(&debug, "d", false, "Turn on debug logging")
	flag.BoolVar(&audio, "a", false, "If true, GoTube will download video's audio as well")

	flag.Parse()
	args := flag.Args()

	if debug {
		log.SetPrefix("\n")
	} else {
		log.SetOutput(ioutil.Discard)
	}
	if outputDirectory == "" {
		flag.Usage()
		os.Exit(1)
	}

	download(args)
}
